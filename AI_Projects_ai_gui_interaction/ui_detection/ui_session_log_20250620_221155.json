[
  {
    "timestamp": "2025-06-20T22:11:55.486384",
    "window_info": {
      "app_name": "Terminal",
      "x": 1524,
      "y": 560,
      "width": 570,
      "height": 371,
      "timestamp": "2025-06-20T22:11:52.026447"
    },
    "profile_used": "browser_chat",
    "input_coordinates": [
      1809,
      893
    ],
    "existing_content": "Last login: Fri Jun 20 22:06:55 on ttys013\njonstiles@Jon-Stiless-iMac ~ % cd /Users/jonstiles/Desktop/ui\\ detection/      \njonstiles@Jon-Stiless-iMac ui detection % python3 /Users/jonstiles/Desktop/ui\\ detection/production_ui_system.py\n\ud83d\ude80 Production UI Automation System Demo\n==================================================\n\n\ud83d\udccb Test 1: Window Detection\n\u2705 Active window: Google Chrome\n   Size: 1529x1049\n   Position: (0, 25)\n   Profile: browser_chat\n   Input coordinates: (764, 969)\n\n\ud83d\udccb Test 2: Content Capture\nSwitch to your chat app and put some text in the input field. Press Enter when ready...\n\u2705 Captured content: '#!/usr/bin/env python3\n\"\"\"\nProduction UI Automation System\nWindow-aware targeting with copy/paste integration\nBuilt on Jon's breakthrough insights\n\"\"\"\n\nimport pyautogui\nimport subprocess\nimport time\nimport os\nimport json\nfrom datetime import datetime\nfrom PIL import ImageGrab\n\nclass ProductionUISystem:\n    \"\"\"Complete UI automation with window detection and copy/paste\"\"\"\n    \n    def __init__(self):\n        self.screen_width, self.screen_height = ImageGrab.grab().size\n        self.session_log = []\n        self.app_profiles = {\n            \"browser_chat\": {\n                \"x_factor\": 0.5,    # Center of window\n                \"y_factor\": 0.9,    # Bottom 10%\n                \"apps\": [\"Google Chrome\", \"Firefox\", \"Safari\"]\n            },\n            \"claude_native\": {\n                \"x_factor\": 0.5,\n                \"y_factor\": 0.85,\n                \"apps\": [\"Claude\"]\n            },\n            \"discord\": {\n                \"x_factor\": 0.5, \n                \"y_factor\": 0.95,\n                \"apps\": [\"Discord\"]\n            }\n        }\n    \n    def get_active_window_info(self):\n        \"\"\"Get current active window details\"\"\"\n        try:\n            script = '''\n            tell application \"System Events\"\n                set frontApp to first application process whose frontmost is true\n                set appName to name of frontApp\n                \n                tell frontApp\n                    try\n                        set winPos to position of front window\n                        set winSize to size of front window\n                        return appName & \"|\" & (item 1 of winPos) & \",\" & (item 2 of winPos) & \"|\" & (item 1 of winSize) & \",\" & (item 2 of winSize)\n                    on error\n                        return appName & \"|0,0|\" & (my desktop_width) & \",\" & (my desktop_height)\n                    end try\n                end tell\n            end tell\n            '''\n            \n            result = subprocess.run(['osascript', '-e', script], \n                                  capture_output=True, text=True)\n            \n            if result.returncode == 0:\n                parts = result.stdout.strip().split('|')\n                app_name = parts[0]\n                \n                if len(parts) >= 3:\n                    pos = list(map(int, parts[1].split(',')))\n                    size = list(map(int, parts[2].split(',')))\n                    \n                    return {\n                        'app_name': app_name,\n                        'x': pos[0],\n                        'y': pos[1],\n                        'width': size[0], \n                        'height': size[1],\n                        'timestamp': datetime.now().isoformat()\n                    }\n            \n        except Exception as e:\n            self.log_event(\"error\", f\"Window detection failed: {e}\")\n        \n        return None\n    \n    def determine_app_profile(self, app_name):\n        \"\"\"Match app name to UI profile\"\"\"\n        app_lower = app_name.lower()\n        \n        for profile_name, profile in self.app_profiles.items():\n            for app in profile['apps']:\n                if app.lower() in app_lower:\n                    return profile_name, profile\n        \n        # Default to browser chat for unknown apps\n        return \"browser_chat\", self.app_profiles[\"browser_chat\"]\n    \n    def calculate_input_coordinates(self, window_info, profile):\n        \"\"\"Calculate input field coordinates within window\"\"\"\n        \n        input_x = window_info['x'] + int(window_info['width'] * profile['x_factor'])\n        input_y = window_info['y'] + int(window_info['height'] * profile['y_factor'])\n        \n        return (input_x, input_y)\n    \n    def click_and_focus_input(self, coordinates):\n        \"\"\"Click input field and ensure it's focused\"\"\"\n        \n        x, y = coordinates\n        \n        # Click to focus\n        pyautogui.click(x, y)\n        time.sleep(0.3)  # Allow focus to register\n        \n        # Verify focus by checking if we can type\n        return True  # For now, assume success\n    \n    def capture_input_content(self, coordinates):\n        \"\"\"Capture all content from input field\"\"\"\n        \n        # Ensure input is focused\n        self.click_and_focus_input(coordinates)\n        \n        # Select all content\n        pyautogui.hotkey(\"command\", \"a\")\n        time.sleep(0.1)\n        \n        # Copy to clipboard\n        pyautogui.hotkey(\"command\", \"c\") \n        time.sleep(0.1)\n        \n        # Get clipboard content\n        try:\n            content = subprocess.check_output(\"pbpaste\", universal_newlines=True).strip()\n            return content\n        except Exception as e:\n            self.log_event(\"error\", f\"Clipboard capture failed: {e}\")\n            return \"\"\n    \n    def send_text_to_input(self, coordinates, text, send_after=False):\n        \"\"\"Send text to input field and optionally press send\"\"\"\n        \n        # Focus input field\n        self.click_and_focus_input(coordinates)\n        \n        # Clear existing content\n        pyautogui.hotkey(\"command\", \"a\")\n        time.sleep(0.1)\n        \n        # Type new content\n        pyautogui.typewrite(text)\n        time.sleep(0.2)\n        \n        if send_after:\n            # Look for send button or use Enter\n            pyautogui.press(\"enter\")\n            time.sleep(0.5)\n        \n        return True\n    \n    def find_send_button(self, window_info):\n        \"\"\"Find send button relative to input field\"\"\"\n        \n        # Send buttons are typically:\n        # - To the right of input field\n        # - Same vertical level or slightly offset\n        \n        input_coords = self.calculate_input_coordinates(\n            window_info, \n            self.app_profiles[\"browser_chat\"]\n        )\n        \n        # Try common send button positions relative to input\n        send_candidates = [\n            (input_coords[0] + 100, input_coords[1]),      # Right of input\n            (input_coords[0] + 150, input_coords[1]),      # Further right\n            (input_coords[0] + 200, input_coords[1] - 10), # Right and up\n        ]\n        \n        return send_candidates[0]  # Return best guess for now\n    \n    def complete_message_exchange(self, message_to_send):\n        \"\"\"Complete workflow: capture current content, send new message\"\"\"\n        \n        window_info = self.get_active_window_info()\n        if not window_info:\n            self.log_event(\"error\", \"No active window detected\")\n            return None\n        \n        profile_name, profile = self.determine_app_profile(window_info['app_name'])\n        input_coords = self.calculate_input_coordinates(window_info, profile)\n        \n        self.log_event(\"info\", f\"Targeting {window_info['app_name']} using {profile_name} profile\")\n        self.log_event(\"info\", f\"Input coordinates: {input_coords}\")\n        \n        # Capture existing content\n        existing_content = self.capture_input_content(input_coords)\n        \n        # Send new message\n        success = self.send_text_to_input(input_coords, message_to_send, send_after=True)\n        \n        result = {\n            'timestamp': datetime.now().isoformat(),\n            'window_info': window_info,\n            'profile_used': profile_name,\n            'input_coordinates': input_coords,\n            'existing_content': existing_content,\n            'message_sent': message_to_send,\n            'success': success\n        }\n        \n        self.session_log.append(result)\n        return result\n    \n    def log_event(self, level, message):\n        \"\"\"Log system events\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        print(f\"[{timestamp}] {level.upper()}: {message}\")\n    \n    def save_session_log(self, filename=None):\n        \"\"\"Save session log to file\"\"\"\n        if not filename:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"ui_session_log_{timestamp}.json\"\n        \n        with open(filename, 'w') as f:\n            json.dump(self.session_log, f, indent=2)\n        \n        self.log_event(\"info\", f\"Session log saved: {filename}\")\n        return filename\n\ndef demo_production_system():\n    \"\"\"Demonstrate the complete production system\"\"\"\n    \n    print(\"\ud83d\ude80 Production UI Automation System Demo\")\n    print(\"=\" * 50)\n    \n    ui_system = ProductionUISystem()\n    \n    # Test 1: Window detection and profiling\n    print(\"\\n\ud83d\udccb Test 1: Window Detection\")\n    window_info = ui_system.get_active_window_info()\n    \n    if window_info:\n        print(f\"\u2705 Active window: {window_info['app_name']}\")\n        print(f\"   Size: {window_info['width']}x{window_info['height']}\")\n        print(f\"   Position: ({window_info['x']}, {window_info['y']})\")\n        \n        profile_name, profile = ui_system.determine_app_profile(window_info['app_name'])\n        print(f\"   Profile: {profile_name}\")\n        \n        coords = ui_system.calculate_input_coordinates(window_info, profile)\n        print(f\"   Input coordinates: {coords}\")\n    \n    # Test 2: Content capture\n    print(f\"\\n\ud83d\udccb Test 2: Content Capture\")\n    response = input(\"Switch to your chat app and put some text in the input field. Press Enter when ready...\")\n    \n    if window_info:\n        profile_name, profile = ui_system.determine_app_profile(window_info['app_name'])\n        coords = ui_system.calculate_input_coordinates(window_info, profile)\n        \n        content = ui_system.capture_input_content(coords)\n        print(f\"\u2705 Captured content: '{content}'\")\n    \n    # Test 3: Message sending\n    print(f\"\\n\ud83d\udccb Test 3: Message Sending\")\n    test_message = \"Hello from the Production UI System! \ud83d\ude80\"\n    \n    response = input(f\"Send test message '{test_message}'? (y/n): \")\n    if response.lower() == 'y':\n        result = ui_system.complete_message_exchange(test_message)\n        if result and result['success']:\n            print(\"\u2705 Message sent successfully!\")\n        else:\n            print(\"\u274c Message sending failed\")\n    \n    # Save session log\n    log_file = ui_system.save_session_log()\n    print(f\"\\n\ud83d\udcbe Session complete - log saved as {log_file}\")\n\nif __name__ == \"__main__\":\n    demo_production_system()'\n\n\ud83d\udccb Test 3: Message Sending\nSend test message 'Hello from the Production UI System! \ud83d\ude80'? (y/n): y\n[22:11:52] INFO: Targeting Terminal using browser_chat profile\n[22:11:52] INFO: Input coordinates: (1809, 893)",
    "message_sent": "Hello from the Production UI System! \ud83d\ude80",
    "success": true
  }
]